" This is CyberLeo's .vimrc file
" vim:set ts=2 sts=2 sw=2 expandtab:
"
"------------------------------------------------------ PATHOGEN - plugins ---
set nocompatible

filetype off
runtime bundle/vim-pathogen/autoload/pathogen.vim
execute pathogen#infect()
execute pathogen#helptags()
filetype plugin indent on
set sessionoptions-=options

"-------------------------------------------------------- CYBERAMA - begin ---
" VIM BOOK {{{
nnoremap <leader>v :split $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
inoremap jk <esc>
nnoremap <Leader>s <Plug>(easymotion-s)
nnoremap <silent> <leader>d <Plug>DashSearch
" vim-uninpaired: nnoremap <leader>l :setlocal number!<cr>
" }}}

" augroup reload_vimrc " {
"   au!
"   au BufWritePost $MYVIMRC source $MYVIMRC
" augroup END " }

"let mapleader=","
"let g:ackprg          = 'ag --nogroup --nocolor --column'
"let g:netrw_liststyle = 3 " = 3: tree style listing
let g:netrw_altfile   = 1 " <C-6> returns to files

let g:ragtag_global_maps = 1

" global defaults {{{
set ts=2 sts=2 sw=2 sr et nowrap
set noswapfile hlsearch cursorline
set ignorecase smartcase

set laststatus=2 " Always display the statusline in all windows
set showtabline=2

set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
set switchbuf=useopen
"set winwidth=79
set showfulltag
set incsearch
set autowriteall
set updatetime=2000
"set shortmess+=I
set shortmess+=filmnrxoOtT          " Abbrev. of messages (avoids 'hit enter')
set termencoding=utf-8 encoding=utf-8
set visualbell noerrorbells
set splitbelow splitright
set number "relativenumber
set rtp+=/usr/local/opt/fzf
if executable('rg')
  set grepprg=rg\ --vimgrep
endif

" Autosave on focus lost
autocmd FocusLost * silent! wa
let g:auto_save = 0

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=
" keep more context when scrolling off the end of a buffer
set scrolloff=2
" Store temporary files in a central spot
set undodir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backup                  " Backups are nice ...
if has('persistent_undo')
    set undofile                " So is persistent undo ...
    set undolevels=1000         " Maximum number of changes that can be undone
    set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
endif
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
" display incomplete commands
set showcmd
" make tab completion for files/buffers act like bash
set wildmenu
set wildmode=full "list:full
set wildignore=*.swp,*.bak,*.pyc,*.class
" Insert only one space when joining lines that contain sentence-terminating
" punctuation like `.`.
set nojoinspaces
" If a file is changed outside of vim, automatically reload it without asking
set autoread
set autoindent copyindent smartindent

" copied from spf13
set mouse=a mousehide
scriptencoding utf-8
set viewoptions=folds,options,cursor,unix,slash
set history=1000
set iskeyword-=.                    " '.' is an end of word designator
set iskeyword-=#                    " '#' is an end of word designator
set iskeyword-=-                    " '-' is an end of word designator
set list
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace
autocmd BufNewFile,BufRead *.coffee set filetype=coffee

" create intermediary directories
fun! <SID>AutoMakeDirectory()
  let s:directory = expand("<afile>:p:h")
  if !isdirectory(s:directory)
    call mkdir(s:directory, "p")
  endif
endfun
autocmd BufWritePre,FileWritePre * :call <SID>AutoMakeDirectory()

cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

noremap Q !!sh<CR>
if exists(':tnoremap')
  tnoremap <Esc> <C-\><C-n>
  tnoremap <A-h> <C-\><C-n><C-w>h
  tnoremap <A-j> <C-\><C-n><C-w>j
  tnoremap <A-k> <C-\><C-n><C-w>k
  tnoremap <A-l> <C-\><C-n><C-w>l
  nnoremap <A-h> <C-w>h
  nnoremap <A-j> <C-w>j
  nnoremap <A-k> <C-w>k
  nnoremap <A-l> <C-w>l
endif

set completeopt=menu,preview,longest

if isdirectory(expand("~/.vim/bundle/undotree/"))
  nnoremap <Leader>u :UndotreeToggle<CR>
  " If undotree is opened, it is likely one wants to interact with it.
  let g:undotree_SetFocusWhenToggle=1
endif



" Random themes!
if &term =~ '256color'
  if !has("gui_running")
    set term=xterm-256color
  endif

  set t_Co=256

  " disable Background Color Erase (BCE) so that color schemes
  " render properly when inside 256-color tmux and GNU screen.
  " see also http://snk.tuxfamily.org/log/vim-256color-bce.html
  set t_ut=
endif

set background=dark
syntax on

if (has("termguicolors")) " Or if you have Neovim >= 0.1.5
  let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
  set termguicolors
endif

if has('lua')
  function! s:turn_column_off()
    set colorcolumn=0
    "highlight ColorColumn ctermbg=magenta
    call matchadd('ColorColumn', '\%79v', 100)
  endfunction

  function! s:pick_random_theme()
lua <<EOF
    math.randomseed(os.time())
    local themes = {'BlackSea', 'Chasing_Logic', 'CodeFactoryv3', 'Monokai', 'MountainDew', 'SlateDark', 'Tomorrow-Night', 'Tomorrow-Night-Eighties', 'abra', 'anotherdark', 'apprentice', 'asu1dark', 'babymate256', 'badwolf', 'base16-atelierdune', 'bensday', 'billw', 'blackboard', 'blackdust', 'blacklight', 'blazer', 'bluechia', 'bluegreen', 'blugrine', 'bocau', 'bubblegum', 'burnttoast256', 'busybee', 'bvemu', 'camo', 'candy', 'candycode', 'candyman', 'carvedwood', 'chance-of-storm', 'chocolate', 'clearance', 'cobaltish', 'codeschool', 'coffee', 'corn', 'corporation', 'cthulhian', 'darkBlue', 'darkZ', 'darkbone', 'darkburn', 'darkeclipse', 'darker-robin', 'darkerdesert', 'darkocean', 'darkrobot', 'darkspectrum', 'desert', 'desert256v2', 'desertEx', 'desertedocean', 'detailed', 'distinguished', 'doriath', 'dusk', 'earendel', 'eclm_wombat', 'ecostation', 'ego', 'ekinivim', 'elise', 'flatcolor', 'flatland', 'flattr', 'fnaqevan', 'forneus', 'freya', 'fu', 'getafe', 'golden', 'gor', 'gotham256', 'graywh', 'grb256', 'greyblue', 'gruvbox', 'guardian', 'herald', 'hybrid', 'industrial', 'inkpot', 'jelleybeans', 'jellyx', 'kellys', 'kib_darktango', 'kkruby', 'kolor', 'lilypink', 'lizard256', 'lodestone', 'luna', 'made_of_code', 'mango', 'manuscript', 'mdark', 'midnight', 'mint', 'monokain', 'moria', 'motus', 'mrpink', 'muon', 'mustang', 'native', 'nazca', 'neon', 'nevfn', 'nightVision', 'nightflight2', 'no_quarter', 'obsidian2', 'pacific', 'peppers', 'pf_earth', 'phd', 'pw', 'quagmire', 'radicalgoodspeed', 'railscasts', 'rainbow_neon', 'rdark', 'refactor', 'robinhood', 'rootwater', 'selenitic', 'seoul256', 'settlemyer', 'sexy-railscasts', 'shobogenzo', 'sift', 'skittles_berry', 'softbluev2', 'sonofobsidian', 'sorcerer', 'southwest-fog', 'strawimodo', 'symfony', 'synic', 'tchaba', 'tesla', 'twilight', 'two2tango', 'umber-green', 'up', 'vilight', 'void', 'watermark', 'wombat256', 'zenburn', '0x7A69_dark'}
    local theme = themes[math.random(1,#themes)]
    local col = 'call <SID>turn_column_off() | set background=dark'
    local log = string.format('redraw | echo "Loaded theme %s"', theme)
    local cmd = string.format('color %s | %s | %s', theme, col, log)
    vim.command(cmd)
EOF
  endfunction

  nnoremap <expr> <F5> <SID>pick_random_theme()
  "silent call <SID>pick_random_theme()
end
set fillchars=vert:│,fold:-
highlight VertSplit cterm=none ctermbg=none ctermfg=247

" let g:base16colorspace=256
" color base16-tomorrow-night

let g:gruvbox_improved_strings=0
let g:gruvbox_improved_warnings=1
let g:gruvbox_contrast_dark='dark'
color gruvbox

"let g:two_firewatch_italics=1
"color two-firewatch
"let g:airline_theme='twofirewatch'

"color sierra

"highlight Normal ctermbg=NONE
"highlight nonText ctermbg=NONE
" }}}

" Mappings to easily toggle fold levels
nnoremap z0 :setlocal foldlevel=0<cr>
nnoremap z1 :setlocal foldlevel=1<cr>
nnoremap z2 :setlocal foldlevel=2<cr>
nnoremap z3 :setlocal foldlevel=3<cr>
nnoremap z4 :setlocal foldlevel=4<cr>
nnoremap z5 :setlocal foldlevel=5<cr>

if 0 " if 0 / endif HACK
i

" Folding rules {{{
set foldenable                  " enable folding
set foldcolumn=2                " add a fold column
set foldmethod=marker           " detect triple-{ style fold markers
set foldlevelstart=99           " start out with everything unfolded
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
                                " which commands trigger auto-unfold
function! MyFoldText()
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction
set foldtext=MyFoldText()

" }}}

.
endif

" This autocommand jumps to the last known position in a file
" just after opening it, if the '" mark is set:
augroup JumpToLastPosition
  au!
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
  au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
augroup END

" Subtle search highlights
highlight Search ctermbg=black ctermfg=yellow term=underline

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

" Alternate buffer (easier than <C-^>)
nmap <leader><leader> <c-^>

" See http://stevelosh.com/blog/2010/09/coming-home-to-vim
nnoremap / /\v
vnoremap / /\v

" Move visual block
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

" un/indent
vnoremap <Tab> >gv
vnoremap <S-Tab> <LT>gv

" Disable highlight when <leader><cr> is pressed
map <silent> <leader><cr> :noh<cr>

" buffer navigation from Practical Vim Book
nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <leader>w <C-w>v<C-w>l
nnoremap <leader>l <C-l>

" Open window below instead of above"
nnoremap <c-w>N :let sb=&sb<BAR>set sb<BAR>new<BAR>let &sb=sb<CR>

" Vertical equivalent of c-w-n and c-w-N"
nnoremap <c-w>v :vnew<CR>
nnoremap <c-w>V :let spr=&spr<BAR>set nospr<BAR>vnew<BAR>let &spr=spr<CR>

" Easier split resizing (shift - and shift +)
nnoremap _ <c-w>-
nnoremap + <c-w>+
if has("autocmd")
  autocmd WinEnter,BufWinEnter *
        \ silent! nunmap <|
        \ silent! nunmap >|
        \ if winnr('$') > 1 |
        \   if winnr() == 1|
        \     nnoremap < <c-w><|
        \     nnoremap > <c-w>>|
        \   else|
        \     nnoremap < <c-w>>|
        \     nnoremap > <c-w><|
        \   endif |
        \ endif
endif

nmap <silent> <leader>Tt :TestNearest<CR>
nmap <silent> <leader>TT :TestFile<CR>
nmap <silent> <leader>Ta :TestSuite<CR>
nmap <silent> <leader>Tl :TestLast<CR>
nmap <silent> <leader>Tg :TestVisit<CR>

if has("gui_macvim") && has("gui_running")
  xmap <D-/> <Plug>Commentary
  imap <D-/> <Plug>Commentary
  nmap <D-/> <Plug>CommentaryLine
else
  nmap <leader>/ <Plug>CommentaryLine
  xmap <leader>/ <Plug>Commentary
endif

" <FZF>
" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)
" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
nnoremap <leader>b :Buffers<cr>
nnoremap <leader>f :Ag<space>
nnoremap <leader>m :Maps<cr>
nnoremap <leader>s :Snippets<cr>
nnoremap <leader>t :Files<cr>
" </FZF>

" Dont fold foldable files by default
if has("autocmd")
  augroup Unfolding
    autocmd!
    autocmd BufRead * normal zR
  augroup END
endif

" Spell checking for git commit messages
if has("autocmd")
  augroup GitCommitSpellCheck
    autocmd!
    autocmd FileType gitcommit set spell
  augroup END
endif


if has("autocmd") && exists("+omnifunc")
  augroup OmniFunk
    autocmd!
    autocmd Filetype *
          \if &omnifunc == "" |
          \setlocal omnifunc=syntaxcomplete#Complete |
          \endif
    autocmd FileType ruby,eruby let ruby_fold = 1
    autocmd FileType ruby,eruby let ruby_spellcheck_strings = 1
    autocmd FileType ruby,eruby set keywordprg=ri " use ruby's ri instead of man for K command
    autocmd FileType ruby,eruby UltiSnipsAddFiletypes rails.ruby

    autocmd FileType ruby let &l:tags = pathogen#legacyjoin(pathogen#uniq(
          \ pathogen#split(&tags) +
          \ map(split($GEM_PATH,':'),'v:val."/gems/*/tags"')))
  augroup END
endif

if ! has('gui_running')
    set ttimeoutlen=10 lazyredraw
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType c set omnifunc=ccomplete#Complete
autocmd FileType ruby,eruby set omnifunc=syntaxcomplete#Complete

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""" RENAME CURRENT FILE
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

""""""""""""""""""""""""""""""""""""""""""""""" RemoveFancyCharacters COMMAND
function! RemoveFancyCharacters()
    let typo = {}
    let typo["“"] = '"'
    let typo["”"] = '"'
    let typo["‘"] = "'"
    let typo["’"] = "'"
    let typo["–"] = '--'
    let typo["—"] = '---'
    let typo["…"] = '...'
    :exe ":%s/".join(keys(typo), '\|').'/\=typo[submatch(0)]/ge'
endfunction
command! RemoveFancyCharacters :call RemoveFancyCharacters()

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Reg COMMAND
function! Reg()
    reg
    echo "Register: "
    let char = nr2char(getchar())
    if char != "\<Esc>"
        execute "normal! \"".char."p"
    endif
    redraw
endfunction

command! -nargs=0 Reg call Reg()

"--------------------------------------------------------- vim-easymotion ---
let g:EasyMotion_do_mapping = 0 " Disable default mappings

" Turn on case sensitive feature
let g:EasyMotion_smartcase = 1

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

" Neomake
autocmd! BufWritePost * Neomake

" let terminal resize scale the internal windows
autocmd VimResized * :wincmd =

"-------------------------------------------------------------- ultisnips ---
" UltiSnips config
" make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion    = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion  = ['<C-p>', '<Up>']
"let g:SuperTabDefaultCompletionType    = '<C-n>'
let g:SuperTabDefaultCompletionType     = 'context'
let g:SuperTabCompletionContexts        = ['s:ContextText', 's:ContextDiscover']
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabMappingForward            = '<tab>'
let g:SuperTabMappingBackward           = '<s-tab>'
let g:SuperTabCrMapping                 = 1
autocmd FileType *
      \ if &omnifunc != '' |
      \   call SuperTabChain(&omnifunc, "<c-p>") |
      \ endif

" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

"--------------------------------------------------------------- Deoplete ---
let g:deoplete#enable_at_startup = 1
let g:deoplete#enable_smart_case = 1
" let g:deoplete#enable_refresh_always = 1
let g:deoplete#enable_camel_case = 1
let g:deoplete#auto_complete_start_length = 2
let g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'

if !exists('g:deoplete#omni#input_patterns')
  let g:deoplete#omni#input_patterns = {}
endif

" tab-complete
let g:ulti_expand_or_jump_res = 0
function ExpandSnippetOrTab()
    let snippet = UltiSnips#ExpandSnippetOrJump()
    if g:ulti_expand_or_jump_res > 0
        return snippet
    else
        return "\<c-n>"
    endif
endfunction
inoremap <silent><expr> <Tab>
      \ pumvisible() ? "<C-R>=ExpandSnippetOrTab()<CR>" :
      \ "\<Tab>"

"------------------------------------------------------------ editorconfig ---
" from https://zerokspot.com/weblog/2016/07/10/editorconfig-in-neovim/
let g:EditorConfig_exec_path = '/usr/local/bin/editorconfig'
let g:EditorConfig_core_mode = 'external_command'

"--------------------------------------------------------------- RSpec.vim ---
map <Leader>rt :call RunCurrentSpecFile()<CR>
map <Leader>rs :call RunNearestSpec()<CR>
map <Leader>rl :call RunLastSpec()<CR>
map <Leader>ra :call RunAllSpecs()<CR>
"let g:rspec_runner = "os_x_iterm2"

"------------------------------------------------------------------ EMMET ---
let g:user_emmet_expandabbr_key = '<Tab>'
let g:use_emmet_complete_tag = 1

"--------------------------------------------------------------- SplitJoin ---
let g:splitjoin_align = 1

"----------------------------------------------------------------- AIRLINE ---
let g:airline#extensions#tabline#enabled = 0
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#buffer_idx_mode = 1

if 0 " if 0 / endif HACK
i

.
endif

"}}}
