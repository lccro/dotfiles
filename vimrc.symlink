" This is CyberLeo's .vimrc file
" vim:set ts=2 sts=2 sw=2 expandtab:
"
"------------------------------------------------------ PATHOGEN - plugins ---
" do use sensible defaults but let me override them
"runtime! plugin/sensible.vim

set nocompatible

filetype off
runtime bundle/vim-pathogen/autoload/pathogen.vim
execute pathogen#infect()
execute pathogen#helptags()
filetype plugin indent on
set sessionoptions-=options

"-------------------------------------------------------- CYBERAMA - begin ---
" VIM BOOK {{{
nnoremap <leader>ev :split $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
inoremap jk <esc>
nnoremap <Leader>s <Plug>(easymotion-s)
nnoremap <leader>l :setlocal number!<cr>
" }}}

"let mapleader=","
"let g:ackprg          = 'ag --nogroup --nocolor --column'
"let g:netrw_liststyle = 3 " = 3: tree style listing
let g:netrw_altfile   = 1 " <C-6> returns to files

let g:ragtag_global_maps = 1

" global defaults {{{
set ts=2 sts=2 sw=2 sr et nowrap
set nobackup noswapfile hlsearch "cursorline
set ignorecase smartcase

set laststatus=2 " Always display the statusline in all windows
set showtabline=2

set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
set switchbuf=useopen
"set winwidth=79
"set number " <leader>l
set showfulltag
set incsearch
set autowriteall
set keywordprg=ri " user ruby's ri instead of man for K command
set updatetime=2000
set pastetoggle=<leader>o "<F4>
set shortmess+=I
set termencoding=utf-8 encoding=utf-8
set visualbell noerrorbells
set splitbelow splitright

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=
" keep more context when scrolling off the end of a buffer
set scrolloff=2
" Store temporary files in a central spot
"set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
" display incomplete commands
set showcmd
" make tab completion for files/buffers act like bash
set wildmenu
set wildmode=full "list:full
set wildignore=*.swp,*.bak,*.pyc,*.class
" Insert only one space when joining lines that contain sentence-terminating
" punctuation like `.`.
set nojoinspaces
" If a file is changed outside of vim, automatically reload it without asking
set autoread
set autoindent copyindent smartindent

" Random themes!
set t_Co=256
syntax on

if has('lua')
  function! s:turn_column_off()
    set colorcolumn=0
    "highlight ColorColumn ctermbg=magenta
    call matchadd('ColorColumn', '\%81v', 100)
  endfunction

  function! s:pick_random_theme()
lua <<EOF
    math.randomseed(os.time())
    local themes = {'BlackSea', 'Chasing_Logic', 'CodeFactoryv3', 'Monokai', 'MountainDew', 'SlateDark', 'Tomorrow-Night', 'Tomorrow-Night-Eighties', 'abra', 'anotherdark', 'apprentice', 'asu1dark', 'babymate256', 'badwolf', 'base16-atelierdune', 'bensday', 'billw', 'blackboard', 'blackdust', 'blacklight', 'blazer', 'bluechia', 'bluegreen', 'blugrine', 'bocau', 'bubblegum', 'burnttoast256', 'busybee', 'bvemu', 'camo', 'candy', 'candycode', 'candyman', 'carvedwood', 'chance-of-storm', 'chocolate', 'clearance', 'cobaltish', 'codeschool', 'coffee', 'corn', 'corporation', 'cthulhian', 'darkBlue', 'darkZ', 'darkbone', 'darkburn', 'darkeclipse', 'darker-robin', 'darkerdesert', 'darkocean', 'darkrobot', 'darkspectrum', 'desert', 'desert256v2', 'desertEx', 'desertedocean', 'detailed', 'distinguished', 'doriath', 'dusk', 'earendel', 'eclm_wombat', 'ecostation', 'ego', 'ekinivim', 'elise', 'flatcolor', 'flatland', 'flattr', 'fnaqevan', 'forneus', 'freya', 'fu', 'getafe', 'golden', 'gor', 'gotham256', 'graywh', 'grb256', 'greyblue', 'gruvbox', 'guardian', 'herald', 'hybrid', 'industrial', 'inkpot', 'jelleybeans', 'jellyx', 'kellys', 'kib_darktango', 'kkruby', 'kolor', 'lilypink', 'lizard256', 'lodestone', 'luna', 'made_of_code', 'mango', 'manuscript', 'mdark', 'midnight', 'mint', 'monokain', 'moria', 'motus', 'mrpink', 'muon', 'mustang', 'native', 'nazca', 'neon', 'nevfn', 'nightVision', 'nightflight2', 'no_quarter', 'obsidian2', 'pacific', 'peppers', 'pf_earth', 'phd', 'pw', 'quagmire', 'radicalgoodspeed', 'railscasts', 'rainbow_neon', 'rdark', 'refactor', 'robinhood', 'rootwater', 'selenitic', 'seoul256', 'settlemyer', 'sexy-railscasts', 'shobogenzo', 'sift', 'skittles_berry', 'softbluev2', 'sonofobsidian', 'sorcerer', 'southwest-fog', 'strawimodo', 'symfony', 'synic', 'tchaba', 'tesla', 'twilight', 'two2tango', 'umber-green', 'up', 'vilight', 'void', 'watermark', 'wombat256', 'zenburn', '0x7A69_dark'}
    local theme = themes[math.random(1,#themes)]
    local col = 'call <SID>turn_column_off() | set background=dark'
    local log = string.format('redraw | echo "Loaded theme %s"', theme)
    local cmd = string.format('color %s | %s | %s', theme, col, log)
    vim.command(cmd)
EOF
  endfunction

  nnoremap <expr> <F5> <SID>pick_random_theme()
  silent call <SID>pick_random_theme()
else
  color railscasts
end

" }}}

" Folding rules {{{
set foldenable                  " enable folding
set foldcolumn=2                " add a fold column
set foldmethod=marker           " detect triple-{ style fold markers
set foldlevelstart=99           " start out with everything unfolded
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
                                " which commands trigger auto-unfold
function! MyFoldText()
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction
set foldtext=MyFoldText()

" Mappings to easily toggle fold levels
nnoremap z0 :setlocal foldlevel=0<cr>
nnoremap z1 :setlocal foldlevel=1<cr>
nnoremap z2 :setlocal foldlevel=2<cr>
nnoremap z3 :setlocal foldlevel=3<cr>
nnoremap z4 :setlocal foldlevel=4<cr>
nnoremap z5 :setlocal foldlevel=5<cr>
" }}}

" This autocommand jumps to the last known position in a file
" just after opening it, if the '" mark is set:
augroup JumpToLastPosition
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
augroup END

" Subtle search highlights
highlight Search ctermbg=black ctermfg=yellow term=underline

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

" Alternate buffer (easier than <C-^>)
map <leader><leader> <c-^>

" See http://stevelosh.com/blog/2010/09/coming-home-to-vim
nnoremap / /\v
vnoremap / /\v

" Disable highlight when <leader><cr> is pressed
map <silent> <leader><cr> :noh<cr>

map <leader>b :CtrlPBuffer<cr>
map <leader>t :CtrlP<cr>
map <leader>gt :CtrlPTag<cr>
nmap <silent> <leader>d <Plug>DashSearch

" buffer navigation from Practical Vim Book
nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <leader>w <C-w>v<C-w>l
"nnoremap <leader>l <C-l>

" Open window below instead of above"
nnoremap <c-w>N :let sb=&sb<BAR>set sb<BAR>new<BAR>let &sb=sb<CR>

" Vertical equivalent of c-w-n and c-w-N"
nnoremap <c-w>v :vnew<CR>
nnoremap <c-w>V :let spr=&spr<BAR>set nospr<BAR>vnew<BAR>let &spr=spr<CR>

" Easier split resizing (shift - and shift +)
nnoremap _ <c-w>-
nnoremap + <c-w>+
if has("autocmd")
  autocmd WinEnter,BufWinEnter *
        \ silent! nunmap <|
        \ silent! nunmap >|
        \ if winnr('$') > 1 |
        \   if winnr() == 1|
        \     nnoremap < <c-w><|
        \     nnoremap > <c-w>>|
        \   else|
        \     nnoremap < <c-w>>|
        \     nnoremap > <c-w><|
        \   endif |
        \ endif
endif

" Dont fold foldable files by default
if has("autocmd")
  augroup Unfolding
    autocmd!
    autocmd BufRead * normal zR
  augroup END
endif

" Spell checking for git commit messages
if has("autocmd")
  augroup Unfolding
    autocmd!
    autocmd FileType gitcommit set spell
  augroup END
endif

if has("autocmd") && exists("+omnifunc")
  augroup OmniFunk
    autocmd!
    autocmd Filetype *
          \	if &omnifunc == "" |
          \		setlocal omnifunc=syntaxcomplete#Complete |
          \	endif
    autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
    autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
    autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
  augroup END
endif

if ! has('gui_running')
    set ttimeoutlen=10 lazyredraw
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType c set omnifunc=ccomplete#Complete
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete


" For snippet_complete marker.
"if has('conceal')
"  set conceallevel=2 concealcursor=i
"endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""" RENAME CURRENT FILE
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

""""""""""""""""""""""""""""""""""""""""""""""" RemoveFancyCharacters COMMAND
function! RemoveFancyCharacters()
    let typo = {}
    let typo["“"] = '"'
    let typo["”"] = '"'
    let typo["‘"] = "'"
    let typo["’"] = "'"
    let typo["–"] = '--'
    let typo["—"] = '---'
    let typo["…"] = '...'
    :exe ":%s/".join(keys(typo), '\|').'/\=typo[submatch(0)]/ge'
endfunction
command! RemoveFancyCharacters :call RemoveFancyCharacters()

"--------------------------------------------------------- vim-easymotion ---
let g:EasyMotion_do_mapping = 0 " Disable default mappings

" Turn on case sensitive feature
let g:EasyMotion_smartcase = 1

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

"---------------------------------------------------------- NERDCommenter ---
if has("gui_macvim") && has("gui_running")
  map <D-/> <plug>NERDCommenterToggle<CR>
  imap <D-/> <Esc><plug>NERDCommenterToggle<CR>i
else
  map <leader>/ <plug>NERDCommenterToggle<CR>
endif

if has("gui_macvim") && has("gui_running")
  " Command-Shift-F on OSX
  map <D-F> :Ag<space>
else
  " Define <C-F> to a dummy value to see if it would set <C-f> as well.
  map <C-F> :dummy

  if maparg("<C-f>") == ":dummy"
    " <leader>f on systems where <C-f> == <C-F>
    map <leader>f :Ag<space>
  else
    " <C-F> if we can still map <C-f> to <S-Down>
    map <C-F> :Ag<space>
  endif

  map <C-f> <S-Down>
endif

"----------------------------------------------------------------- CTRL_P ---
let g:ctrlp_lazy_update=1
let g:ctrlp_map = ''
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn)$',
  \ 'file': '\.pyc$\|\.pyo$\|\.rbc$|\.rbo$\|\.class$\|\.o$\|\~$\',
  \ }
if has("gui_macvim") && has("gui_running")
  " CMD-t
  map <D-t> :CtrlP<CR>
  imap <D-t> <ESC>:CtrlP<CR>

  " CMD-T
  map <M-D-T> :CtrlPTag<CR>
  imap <M-D-T> <ESC>:CtrlPTag<CR>

  " CMD-B
  map <D-B> :CtrlPBuffer<cr>
  imap <D-B> <ESC>:CtrlPBuffer<cr>
endif


"SYNTASTIC
" set statusline+=%#warningmsg#
" set statusline+=%{SyntasticStatuslineFlag()}
" set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_html_tidy_exec = 'tidy5'
let g:syntastic_loc_list_height = 5

"SUPERTAB
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabLongestEnhanced = 1
let g:SuperTabLongestHighlight = 1
let g:SuperTabDefaultCompletionType = 'context'
autocmd FileType *
      \ if &omnifunc != '' |
      \   call SuperTabChain(&omnifunc, "<c-p>") |
      \ endif

" ULTISNIPS
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

if 0 " if 0 / endif HACK
i

"SYNTASTIC
let g:syntastic_enable_signs=1
let g:syntastic_quiet_messages = {'level': 'warnings'}
let g:syntastic_auto_loc_list=2

.
endif

" define our text-style tabline
" this is adapted (with some enhancements) from the example
" at :help setting-tabline
if exists("+showtabline")
     function MyTabLine()
         let s = ''
         let t = tabpagenr()
         let i = 1
         while i <= tabpagenr('$')
             let buflist = tabpagebuflist(i)
             let winnr = tabpagewinnr(i)
             let s .= '%' . i . 'T'
             let s .= (i == t ? '%1*' : '%2*')
             let s .= ' '
             let s .= i . ':'
             "let s .= winnr . '/' . tabpagewinnr(i,'$')
             let s .= ' %*'
             let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
             let file = bufname(buflist[winnr - 1])
             let file = fnamemodify(file, ':p:t')
             if file == ''
                 let file = '[No Name]'
             endif
             let s .= file
             let i = i + 1
         endwhile
         let s .= '%T%#TabLineFill#%='
         let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
         return s
     endfunction
     set stal=2
     set tabline=%!MyTabLine()
"   map     <F10>    :tabnext<CR>
"   map!    <F10>    <C-O>:tabnext<CR>
"   map     <S-F10>  :tabprev<CR>
"   map!    <S-F10>  <C-O>:tabprev<CR>
endif

