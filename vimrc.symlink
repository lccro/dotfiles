" This is CyberLeo's .vimrc file
" vim:set ts=2 sts=2 sw=2 expandtab:
"
"------------------------------------------------------ PATHOGEN - plugins ---
set nocompatible

filetype off
runtime bundle/vim-pathogen/autoload/pathogen.vim
execute pathogen#infect()
execute pathogen#helptags()
filetype plugin indent on
set sessionoptions-=options

"-------------------------------------------------------- CYBERAMA - begin ---
" VIM BOOK {{{
nnoremap <leader>v :split $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
inoremap jk <esc>
nnoremap <Leader>s <Plug>(easymotion-s)
nnoremap <silent> <leader>d <Plug>DashSearch
" vim-uninpaired: nnoremap <leader>l :setlocal number!<cr>
" }}}

" augroup reload_vimrc " {
"   au!
"   au BufWritePost $MYVIMRC source $MYVIMRC
" augroup END " }

"let mapleader=","
"let g:ackprg          = 'ag --nogroup --nocolor --column'
"let g:netrw_liststyle = 3 " = 3: tree style listing
let g:netrw_altfile   = 1 " <C-6> returns to files

let g:ragtag_global_maps = 1

" global defaults {{{
set ts=2 sts=2 sw=2 sr et nowrap
set noswapfile hlsearch cursorline
set ignorecase smartcase

set laststatus=2 " Always display the statusline in all windows
set showtabline=2

set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
set switchbuf=useopen
"set winwidth=79
set showfulltag
set incsearch
set autowriteall
set updatetime=2000
"set shortmess+=I
set shortmess+=filmnrxoOtT          " Abbrev. of messages (avoids 'hit enter')
set termencoding=utf-8 encoding=utf-8
set visualbell noerrorbells
set splitbelow splitright
set number "relativenumber

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=
" keep more context when scrolling off the end of a buffer
set scrolloff=2
" Store temporary files in a central spot
set undodir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backup                  " Backups are nice ...
if has('persistent_undo')
    set undofile                " So is persistent undo ...
    set undolevels=1000         " Maximum number of changes that can be undone
    set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
endif
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
" display incomplete commands
set showcmd
" make tab completion for files/buffers act like bash
set wildmenu
set wildmode=full "list:full
set wildignore=*.swp,*.bak,*.pyc,*.class
" Insert only one space when joining lines that contain sentence-terminating
" punctuation like `.`.
set nojoinspaces
" If a file is changed outside of vim, automatically reload it without asking
set autoread
set autoindent copyindent smartindent

" copied from spf13
set mouse=a mousehide
scriptencoding utf-8
set viewoptions=folds,options,cursor,unix,slash
set history=1000
set iskeyword-=.                    " '.' is an end of word designator
set iskeyword-=#                    " '#' is an end of word designator
set iskeyword-=-                    " '-' is an end of word designator
set list
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace
autocmd BufNewFile,BufRead *.coffee set filetype=coffee

cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

noremap Q !!sh<CR>
if exists(':tnoremap')
  tnoremap <Esc> <C-\><C-n>
  tnoremap <A-h> <C-\><C-n><C-w>h
  tnoremap <A-j> <C-\><C-n><C-w>j
  tnoremap <A-k> <C-\><C-n><C-w>k
  tnoremap <A-l> <C-\><C-n><C-w>l
  nnoremap <A-h> <C-w>h
  nnoremap <A-j> <C-w>j
  nnoremap <A-k> <C-w>k
  nnoremap <A-l> <C-w>l
endif

set completeopt=menu,preview,longest

if isdirectory(expand("~/.vim/bundle/undotree/"))
  nnoremap <Leader>u :UndotreeToggle<CR>
  " If undotree is opened, it is likely one wants to interact with it.
  let g:undotree_SetFocusWhenToggle=1
endif



" Random themes!
if &term =~ '256color'
  if !has("gui_running")
    set term=xterm-256color
  endif

  set t_Co=256

  " disable Background Color Erase (BCE) so that color schemes
  " render properly when inside 256-color tmux and GNU screen.
  " see also http://snk.tuxfamily.org/log/vim-256color-bce.html
  set t_ut=
endif

set background=dark
syntax on

if (has("termguicolors")) " Or if you have Neovim >= 0.1.5
  let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
  set termguicolors
endif

if has('lua')
  function! s:turn_column_off()
    set colorcolumn=0
    "highlight ColorColumn ctermbg=magenta
    call matchadd('ColorColumn', '\%79v', 100)
  endfunction

  function! s:pick_random_theme()
lua <<EOF
    math.randomseed(os.time())
    local themes = {'BlackSea', 'Chasing_Logic', 'CodeFactoryv3', 'Monokai', 'MountainDew', 'SlateDark', 'Tomorrow-Night', 'Tomorrow-Night-Eighties', 'abra', 'anotherdark', 'apprentice', 'asu1dark', 'babymate256', 'badwolf', 'base16-atelierdune', 'bensday', 'billw', 'blackboard', 'blackdust', 'blacklight', 'blazer', 'bluechia', 'bluegreen', 'blugrine', 'bocau', 'bubblegum', 'burnttoast256', 'busybee', 'bvemu', 'camo', 'candy', 'candycode', 'candyman', 'carvedwood', 'chance-of-storm', 'chocolate', 'clearance', 'cobaltish', 'codeschool', 'coffee', 'corn', 'corporation', 'cthulhian', 'darkBlue', 'darkZ', 'darkbone', 'darkburn', 'darkeclipse', 'darker-robin', 'darkerdesert', 'darkocean', 'darkrobot', 'darkspectrum', 'desert', 'desert256v2', 'desertEx', 'desertedocean', 'detailed', 'distinguished', 'doriath', 'dusk', 'earendel', 'eclm_wombat', 'ecostation', 'ego', 'ekinivim', 'elise', 'flatcolor', 'flatland', 'flattr', 'fnaqevan', 'forneus', 'freya', 'fu', 'getafe', 'golden', 'gor', 'gotham256', 'graywh', 'grb256', 'greyblue', 'gruvbox', 'guardian', 'herald', 'hybrid', 'industrial', 'inkpot', 'jelleybeans', 'jellyx', 'kellys', 'kib_darktango', 'kkruby', 'kolor', 'lilypink', 'lizard256', 'lodestone', 'luna', 'made_of_code', 'mango', 'manuscript', 'mdark', 'midnight', 'mint', 'monokain', 'moria', 'motus', 'mrpink', 'muon', 'mustang', 'native', 'nazca', 'neon', 'nevfn', 'nightVision', 'nightflight2', 'no_quarter', 'obsidian2', 'pacific', 'peppers', 'pf_earth', 'phd', 'pw', 'quagmire', 'radicalgoodspeed', 'railscasts', 'rainbow_neon', 'rdark', 'refactor', 'robinhood', 'rootwater', 'selenitic', 'seoul256', 'settlemyer', 'sexy-railscasts', 'shobogenzo', 'sift', 'skittles_berry', 'softbluev2', 'sonofobsidian', 'sorcerer', 'southwest-fog', 'strawimodo', 'symfony', 'synic', 'tchaba', 'tesla', 'twilight', 'two2tango', 'umber-green', 'up', 'vilight', 'void', 'watermark', 'wombat256', 'zenburn', '0x7A69_dark'}
    local theme = themes[math.random(1,#themes)]
    local col = 'call <SID>turn_column_off() | set background=dark'
    local log = string.format('redraw | echo "Loaded theme %s"', theme)
    local cmd = string.format('color %s | %s | %s', theme, col, log)
    vim.command(cmd)
EOF
  endfunction

  nnoremap <expr> <F5> <SID>pick_random_theme()
  "silent call <SID>pick_random_theme()
end
set fillchars=vert:│,fold:-
highlight VertSplit cterm=none ctermbg=none ctermfg=247

let g:gruvbox_improved_strings=0
let g:gruvbox_improved_warnings=1
let g:gruvbox_contrast_dark='dark'
color gruvbox

"let g:two_firewatch_italics=1
"color two-firewatch
"let g:airline_theme='twofirewatch'

"color sierra

"highlight Normal ctermbg=NONE
"highlight nonText ctermbg=NONE
" }}}

" Mappings to easily toggle fold levels
nnoremap z0 :setlocal foldlevel=0<cr>
nnoremap z1 :setlocal foldlevel=1<cr>
nnoremap z2 :setlocal foldlevel=2<cr>
nnoremap z3 :setlocal foldlevel=3<cr>
nnoremap z4 :setlocal foldlevel=4<cr>
nnoremap z5 :setlocal foldlevel=5<cr>

if 0 " if 0 / endif HACK
i

" Folding rules {{{
set foldenable                  " enable folding
set foldcolumn=2                " add a fold column
set foldmethod=marker           " detect triple-{ style fold markers
set foldlevelstart=99           " start out with everything unfolded
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
                                " which commands trigger auto-unfold
function! MyFoldText()
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction
set foldtext=MyFoldText()

" }}}

.
endif

" This autocommand jumps to the last known position in a file
" just after opening it, if the '" mark is set:
augroup JumpToLastPosition
  au!
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
  au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
augroup END

" Subtle search highlights
highlight Search ctermbg=black ctermfg=yellow term=underline

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

" Alternate buffer (easier than <C-^>)
nmap <leader><leader> <c-^>

" See http://stevelosh.com/blog/2010/09/coming-home-to-vim
nnoremap / /\v
vnoremap / /\v

" Move visual block
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

" un/indent
vnoremap <Tab> >gv
vnoremap <S-Tab> <LT>gv

" Disable highlight when <leader><cr> is pressed
map <silent> <leader><cr> :noh<cr>

" buffer navigation from Practical Vim Book
nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <leader>w <C-w>v<C-w>l
nnoremap <leader>l <C-l>

" Open window below instead of above"
nnoremap <c-w>N :let sb=&sb<BAR>set sb<BAR>new<BAR>let &sb=sb<CR>

" Vertical equivalent of c-w-n and c-w-N"
nnoremap <c-w>v :vnew<CR>
nnoremap <c-w>V :let spr=&spr<BAR>set nospr<BAR>vnew<BAR>let &spr=spr<CR>

" Easier split resizing (shift - and shift +)
nnoremap _ <c-w>-
nnoremap + <c-w>+
if has("autocmd")
  autocmd WinEnter,BufWinEnter *
        \ silent! nunmap <|
        \ silent! nunmap >|
        \ if winnr('$') > 1 |
        \   if winnr() == 1|
        \     nnoremap < <c-w><|
        \     nnoremap > <c-w>>|
        \   else|
        \     nnoremap < <c-w>>|
        \     nnoremap > <c-w><|
        \   endif |
        \ endif
endif

nmap <silent> <leader>Tt :TestNearest<CR>
nmap <silent> <leader>TT :TestFile<CR>
nmap <silent> <leader>Ta :TestSuite<CR>
nmap <silent> <leader>Tl :TestLast<CR>
nmap <silent> <leader>Tg :TestVisit<CR>

if has("gui_macvim") && has("gui_running")
  xmap <D-/> <Plug>Commentary
  imap <D-/> <Plug>Commentary
  nmap <D-/> <Plug>CommentaryLine
else
  nmap <leader>/ <Plug>CommentaryLine
  xmap <leader>/ <Plug>Commentary
endif

" UNITE
" Like ctrlp.vim settings.
call unite#custom#profile('default', 'context', {
\   'start_insert': 1,
\   'winheight': 10,
\   'direction': 'botright',
\ })

call unite#filters#matcher_default#use(['matcher_fuzzy'])
nnoremap <leader>f :<C-u>Unite grep<CR>
nnoremap     <D-f> :<C-u>Unite grep<CR>
if has('nvim')
nnoremap <leader>t :<C-u>Unite file_rec/neovim<CR>
nnoremap     <D-t> :<C-u>Unite file_rec/neovim<CR>
else
nnoremap <leader>t :<C-u>Unite file_rec/async:!<CR>
nnoremap     <D-t> :<C-u>Unite file_rec/async:!<CR>
endif
nnoremap <leader>b :<C-u>Unite buffer bookmark<CR>
nnoremap     <D-b> :<C-u>Unite buffer bookmark<CR>
nnoremap <leader>m :<C-u>Unite mapping<CR>
nnoremap     <D-m> :<C-u>Unite mapping<CR>
nnoremap <leader>l :<C-u>Unite line<CR>
nnoremap     <D-l> :<C-u>Unite line<CR>

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()"{{{
  " Overwrite settings.

  imap <buffer> jj      <Plug>(unite_insert_leave)

  imap <buffer><expr> j unite#smart_map('j', '')
  imap <buffer> <TAB>   <Plug>(unite_select_next_line)
  imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
  imap <buffer> '     <Plug>(unite_quick_match_default_action)
  nmap <buffer> '     <Plug>(unite_quick_match_default_action)
  imap <buffer><expr> x
        \ unite#smart_map('x', "\<Plug>(unite_quick_match_jump)")
  nmap <buffer> x     <Plug>(unite_quick_match_jump)
  nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
  imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
  nmap <buffer> <C-j>     <Plug>(unite_toggle_auto_preview)
  nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
  imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
  nnoremap <silent><buffer><expr> l
        \ unite#smart_map('l', unite#do_action('default'))

  let unite = unite#get_current_unite()
  if unite.profile_name ==# 'search'
    nnoremap <silent><buffer><expr> r     unite#do_action('replace')
  else
    nnoremap <silent><buffer><expr> r     unite#do_action('rename')
  endif

  nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
  nnoremap <buffer><expr> S      unite#mappings#set_current_sorters(
        \ empty(unite#mappings#get_current_sorters()) ?
        \ ['sorter_reverse'] : [])

  " Runs 'split' action by <C-s>.
  imap <silent><buffer><expr> <C-s>     unite#do_action('split')
  imap <silent><buffer><expr> <C-v>     unite#do_action('vsplit')

  if executable('ag')
    " Use ag (the silver searcher)
    " https://github.com/ggreer/the_silver_searcher
    let g:unite_source_rec_async_command =
          \ ['ag', '--follow', '--nocolor', '--nogroup',
          \  '--hidden', '-g', '']
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts =
          \ '-i --vimgrep --hidden --ignore ' .
          \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
  endif
endfunction"}}}


" Dont fold foldable files by default
if has("autocmd")
  augroup Unfolding
    autocmd!
    autocmd BufRead * normal zR
  augroup END
endif

" Spell checking for git commit messages
if has("autocmd")
  augroup GitCommitSpellCheck
    autocmd!
    autocmd FileType gitcommit set spell
  augroup END
endif


if has("autocmd") && exists("+omnifunc")
  augroup OmniFunk
    autocmd!
    autocmd Filetype *
          \if &omnifunc == "" |
          \setlocal omnifunc=syntaxcomplete#Complete |
          \endif
    autocmd FileType ruby,eruby let ruby_fold = 1
    autocmd FileType ruby,eruby let ruby_spellcheck_strings = 1
    autocmd FileType ruby,eruby set keywordprg=ri " use ruby's ri instead of man for K command
    autocmd FileType ruby,eruby UltiSnipsAddFiletypes rails.ruby

    autocmd FileType ruby let &l:tags = pathogen#legacyjoin(pathogen#uniq(
          \ pathogen#split(&tags) +
          \ map(split($GEM_PATH,':'),'v:val."/gems/*/tags"')))
  augroup END
endif

if ! has('gui_running')
    set ttimeoutlen=10 lazyredraw
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType c set omnifunc=ccomplete#Complete
autocmd FileType ruby,eruby set omnifunc=syntaxcomplete#Complete

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""" RENAME CURRENT FILE
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

""""""""""""""""""""""""""""""""""""""""""""""" RemoveFancyCharacters COMMAND
function! RemoveFancyCharacters()
    let typo = {}
    let typo["“"] = '"'
    let typo["”"] = '"'
    let typo["‘"] = "'"
    let typo["’"] = "'"
    let typo["–"] = '--'
    let typo["—"] = '---'
    let typo["…"] = '...'
    :exe ":%s/".join(keys(typo), '\|').'/\=typo[submatch(0)]/ge'
endfunction
command! RemoveFancyCharacters :call RemoveFancyCharacters()

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Reg COMMAND
function! Reg()
    reg
    echo "Register: "
    let char = nr2char(getchar())
    if char != "\<Esc>"
        execute "normal! \"".char."p"
    endif
    redraw
endfunction

command! -nargs=0 Reg call Reg()

"--------------------------------------------------------- vim-easymotion ---
let g:EasyMotion_do_mapping = 0 " Disable default mappings

" Turn on case sensitive feature
let g:EasyMotion_smartcase = 1

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

" Neomake
autocmd! BufWritePost * Neomake

" let terminal resize scale the internal windows
autocmd VimResized * :wincmd =

"-------------------------------------------------------------- ultisnips ---
" UltiSnips config
" Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
let g:UltiSnipsExpandTrigger="<nop>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsUsePythonVersion = 3

"--------------------------------------------------------------- Deoplete ---
let g:deoplete#enable_at_startup = 1
let g:deoplete#enable_smart_case = 1
" let g:deoplete#enable_refresh_always = 1
let g:deoplete#enable_camel_case = 1
let g:deoplete#auto_complete_start_length = 2

if !exists('g:deoplete#omni#input_patterns')
  let g:deoplete#omni#input_patterns = {}
endif

" tab-complete
let g:ulti_expand_or_jump_res = 0
function ExpandSnippetOrTab()
    let snippet = UltiSnips#ExpandSnippetOrJump()
    if g:ulti_expand_or_jump_res > 0
        return snippet
    else
        return "\<c-n>"
    endif
endfunction
inoremap <silent><expr> <Tab>
      \ pumvisible() ? "<C-R>=ExpandSnippetOrTab()<CR>" :
      \ "\<Tab>"

"------------------------------------------------------------------ EMMET ---
let g:user_emmet_expandabbr_key = '<Tab>'
let g:use_emmet_complete_tag = 1

" https://github.com/unblevable/quick-scope
let g:qs_enable = 0
let g:qs_enable_char_list = [ 'f', 'F', 't', 'T' ]

function! Quick_scope_selective(movement)
  let needs_disabling = 0
  if !g:qs_enable
    QuickScopeToggle
    redraw
    let needs_disabling = 1
  endif
  let letter = nr2char(getchar())
  if needs_disabling
    QuickScopeToggle
  endif
  return a:movement . letter
endfunction

" quick_scope maps, operator-pending mode included (can do 'df' with hint)
for i in g:qs_enable_char_list
  execute 'noremap <expr> <silent>' . i . " Quick_scope_selective('". i . "')"
endfor

"SYNTASTIC
let g:syntastic_enable_signs=1
let g:syntastic_check_on_open=1
let g:syntastic_check_on_wq=1
let g:syntastic_aggregate_errors=1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_enable_ballons=has('ballon_eval')
let g:syntastic_always_populate_loc_list=1
let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1
let g:syntastic_loc_list_height=3
let g:syntastic_ignore_files = ['^/usr/', '*node_modules*', '*vendor*', '*build*', '*LOCAL*', '*BASE', '*REMOTE*']
let g:syntastic_mode_map = { 'mode': 'active' }
let g:syntastic_javascript_checkers=['jshint', 'jscs']
let g:syntastic_json_checkers=['jsonlint', 'jsonval']
let g:syntastic_ruby_checkers=['rubocop','mri']
let g:syntastic_perl_checkers=['perl','perlcritic','podchecker']
let g:syntastic_python_checkers=['pylint','pep8','python']
let g:syntastic_cpp_checkers=['gcc','cppcheck','cpplint','clang_tidy','clang_check']
let g:syntastic_c_checkers=['gcc','make','cppcheck','clang_tidy','clang_check']
let g:syntastic_haml_checkers=['haml_lint', 'haml']
let g:syntastic_html_checkers=['jshint']
let g:syntastic_yaml_checkers=['jsyaml']
let g:syntastic_sh_checkers=['sh','shellcheck','checkbashisms']
let g:syntastic_vim_checkers=['vimlint']
let g:syntastic_enable_perl_checker=1
let g:syntastic_c_clang_tidy_sort=1
let g:syntastic_c_clang_check_sort=1
let g:syntastic_c_remove_include_errors=1
let g:syntastic_quiet_messages = { "level": "[]", "file": ['*_LOCAL_*', '*_BASE_*', '*_REMOTE_*']  }
let g:syntastic_stl_format = '[%E{E: %fe #%e}%B{, }%W{W: %fw #%w}]'
let g:syntastic_java_javac_options = "-g:none -source 8 -Xmaxerrs 5 -Xmaswarns 5"

if 0 " if 0 / endif HACK
i


.
endif

" AIRLINE
let g:airline#extensions#tabline#enabled = 0
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#buffer_idx_mode = 1

"}}}
