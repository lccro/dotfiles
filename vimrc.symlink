" This is CyberLeo's .vimrc file
" vim:set ts=2 sts=2 sw=2 expandtab:
"
"------------------------------------------------------ PATHOGEN - plugins ---
set nocompatible

filetype off
runtime bundle/vim-pathogen/autoload/pathogen.vim
execute pathogen#infect()
execute pathogen#helptags()
filetype plugin indent on
set sessionoptions-=options

"-------------------------------------------------------- CYBERAMA - begin ---
"let $NVIM_TUI_ENABLE_TRUE_COLOR=0
let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

" VIM BOOK {{{
nnoremap <leader>v :split $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
inoremap jk <esc>
nnoremap <Leader>s <Plug>(easymotion-s)
nnoremap <silent> <leader>d <Plug>DashSearch
" vim-uninpaired: nnoremap <leader>l :setlocal number!<cr>
" }}}

" augroup reload_vimrc " {
"   au!
"   au BufWritePost $MYVIMRC source $MYVIMRC
" augroup END " }

"let mapleader=","
"let g:ackprg          = 'ag --nogroup --nocolor --column'
"let g:netrw_liststyle = 3 " = 3: tree style listing
let g:netrw_altfile   = 1 " <C-6> returns to files

let g:ragtag_global_maps = 1

" global defaults {{{
set ts=2 sts=2 sw=2 sr et nowrap
set noswapfile hlsearch cursorline
set ignorecase smartcase

set laststatus=2 " Always display the statusline in all windows
set showtabline=2

set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
set switchbuf=useopen
"set winwidth=79
set showfulltag
set incsearch
set autowriteall
set updatetime=2000
"set shortmess+=I
set shortmess+=filmnrxoOtT          " Abbrev. of messages (avoids 'hit enter')
set termencoding=utf-8 encoding=utf-8
set visualbell noerrorbells
set splitbelow splitright
set number "relativenumber

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=
" keep more context when scrolling off the end of a buffer
set scrolloff=2
" Store temporary files in a central spot
set undodir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backup                  " Backups are nice ...
if has('persistent_undo')
    set undofile                " So is persistent undo ...
    set undolevels=1000         " Maximum number of changes that can be undone
    set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
endif
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
" display incomplete commands
set showcmd
" make tab completion for files/buffers act like bash
set wildmenu
set wildmode=full "list:full
set wildignore=*.swp,*.bak,*.pyc,*.class
" Insert only one space when joining lines that contain sentence-terminating
" punctuation like `.`.
set nojoinspaces
" If a file is changed outside of vim, automatically reload it without asking
set autoread
set autoindent copyindent smartindent

" copied from spf13
set mouse=a mousehide
scriptencoding utf-8
set viewoptions=folds,options,cursor,unix,slash
set history=1000
set iskeyword-=.                    " '.' is an end of word designator
set iskeyword-=#                    " '#' is an end of word designator
set iskeyword-=-                    " '-' is an end of word designator
set list
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace
autocmd BufNewFile,BufRead *.coffee set filetype=coffee

cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

noremap Q !!sh<CR>

set completeopt=menu,preview,longest

if isdirectory(expand("~/.vim/bundle/undotree/"))
  nnoremap <Leader>u :UndotreeToggle<CR>
  " If undotree is opened, it is likely one wants to interact with it.
  let g:undotree_SetFocusWhenToggle=1
endif



" Random themes!
set t_Co=256
syntax on

if has('lua')
  function! s:turn_column_off()
    set colorcolumn=0
    "highlight ColorColumn ctermbg=magenta
    call matchadd('ColorColumn', '\%79v', 100)
  endfunction

  function! s:pick_random_theme()
lua <<EOF
    math.randomseed(os.time())
    local themes = {'BlackSea', 'Chasing_Logic', 'CodeFactoryv3', 'Monokai', 'MountainDew', 'SlateDark', 'Tomorrow-Night', 'Tomorrow-Night-Eighties', 'abra', 'anotherdark', 'apprentice', 'asu1dark', 'babymate256', 'badwolf', 'base16-atelierdune', 'bensday', 'billw', 'blackboard', 'blackdust', 'blacklight', 'blazer', 'bluechia', 'bluegreen', 'blugrine', 'bocau', 'bubblegum', 'burnttoast256', 'busybee', 'bvemu', 'camo', 'candy', 'candycode', 'candyman', 'carvedwood', 'chance-of-storm', 'chocolate', 'clearance', 'cobaltish', 'codeschool', 'coffee', 'corn', 'corporation', 'cthulhian', 'darkBlue', 'darkZ', 'darkbone', 'darkburn', 'darkeclipse', 'darker-robin', 'darkerdesert', 'darkocean', 'darkrobot', 'darkspectrum', 'desert', 'desert256v2', 'desertEx', 'desertedocean', 'detailed', 'distinguished', 'doriath', 'dusk', 'earendel', 'eclm_wombat', 'ecostation', 'ego', 'ekinivim', 'elise', 'flatcolor', 'flatland', 'flattr', 'fnaqevan', 'forneus', 'freya', 'fu', 'getafe', 'golden', 'gor', 'gotham256', 'graywh', 'grb256', 'greyblue', 'gruvbox', 'guardian', 'herald', 'hybrid', 'industrial', 'inkpot', 'jelleybeans', 'jellyx', 'kellys', 'kib_darktango', 'kkruby', 'kolor', 'lilypink', 'lizard256', 'lodestone', 'luna', 'made_of_code', 'mango', 'manuscript', 'mdark', 'midnight', 'mint', 'monokain', 'moria', 'motus', 'mrpink', 'muon', 'mustang', 'native', 'nazca', 'neon', 'nevfn', 'nightVision', 'nightflight2', 'no_quarter', 'obsidian2', 'pacific', 'peppers', 'pf_earth', 'phd', 'pw', 'quagmire', 'radicalgoodspeed', 'railscasts', 'rainbow_neon', 'rdark', 'refactor', 'robinhood', 'rootwater', 'selenitic', 'seoul256', 'settlemyer', 'sexy-railscasts', 'shobogenzo', 'sift', 'skittles_berry', 'softbluev2', 'sonofobsidian', 'sorcerer', 'southwest-fog', 'strawimodo', 'symfony', 'synic', 'tchaba', 'tesla', 'twilight', 'two2tango', 'umber-green', 'up', 'vilight', 'void', 'watermark', 'wombat256', 'zenburn', '0x7A69_dark'}
    local theme = themes[math.random(1,#themes)]
    local col = 'call <SID>turn_column_off() | set background=dark'
    local log = string.format('redraw | echo "Loaded theme %s"', theme)
    local cmd = string.format('color %s | %s | %s', theme, col, log)
    vim.command(cmd)
EOF
  endfunction

  nnoremap <expr> <F5> <SID>pick_random_theme()
  "silent call <SID>pick_random_theme()
end
set background=dark
set fillchars=vert:│,fold:-
highlight VertSplit cterm=none ctermbg=none ctermfg=247
let g:gruvbox_improved_strings=0
let g:gruvbox_improved_warnings=1
let g:gruvbox_contrast_dark='dark'
"color vividchalk
"color Dracula
color gruvbox


" }}}

" Folding rules {{{
set foldenable                  " enable folding
set foldcolumn=2                " add a fold column
set foldmethod=marker           " detect triple-{ style fold markers
set foldlevelstart=99           " start out with everything unfolded
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
                                " which commands trigger auto-unfold
function! MyFoldText()
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction
set foldtext=MyFoldText()

" Mappings to easily toggle fold levels
nnoremap z0 :setlocal foldlevel=0<cr>
nnoremap z1 :setlocal foldlevel=1<cr>
nnoremap z2 :setlocal foldlevel=2<cr>
nnoremap z3 :setlocal foldlevel=3<cr>
nnoremap z4 :setlocal foldlevel=4<cr>
nnoremap z5 :setlocal foldlevel=5<cr>
" }}}

" This autocommand jumps to the last known position in a file
" just after opening it, if the '" mark is set:
augroup JumpToLastPosition
  au!
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
  au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
augroup END

" Subtle search highlights
highlight Search ctermbg=black ctermfg=yellow term=underline

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

" Alternate buffer (easier than <C-^>)
map <leader><leader> <c-^>

" See http://stevelosh.com/blog/2010/09/coming-home-to-vim
nnoremap / /\v
vnoremap / /\v

" Disable highlight when <leader><cr> is pressed
map <silent> <leader><cr> :noh<cr>

" buffer navigation from Practical Vim Book
nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <leader>w <C-w>v<C-w>l
nnoremap <leader>l <C-l>

" Open window below instead of above"
nnoremap <c-w>N :let sb=&sb<BAR>set sb<BAR>new<BAR>let &sb=sb<CR>

" Vertical equivalent of c-w-n and c-w-N"
nnoremap <c-w>v :vnew<CR>
nnoremap <c-w>V :let spr=&spr<BAR>set nospr<BAR>vnew<BAR>let &spr=spr<CR>

" Easier split resizing (shift - and shift +)
nnoremap _ <c-w>-
nnoremap + <c-w>+
if has("autocmd")
  autocmd WinEnter,BufWinEnter *
        \ silent! nunmap <|
        \ silent! nunmap >|
        \ if winnr('$') > 1 |
        \   if winnr() == 1|
        \     nnoremap < <c-w><|
        \     nnoremap > <c-w>>|
        \   else|
        \     nnoremap < <c-w>>|
        \     nnoremap > <c-w><|
        \   endif |
        \ endif
endif

" Dont fold foldable files by default
if has("autocmd")
  augroup Unfolding
    autocmd!
    autocmd BufRead * normal zR
  augroup END
endif

" Spell checking for git commit messages
if has("autocmd")
  augroup GitCommitSpellCheck
    autocmd!
    autocmd FileType gitcommit set spell
  augroup END
endif

let g:ycm_min_num_of_chars_for_completion = 0
let g:ycm_auto_trigger = 1
set omnifunc=syntaxcomplete#Complete

if has("autocmd") && exists("+omnifunc")
  augroup OmniFunk
    autocmd!
    autocmd Filetype *
          \if &omnifunc == "" |
          \setlocal omnifunc=syntaxcomplete#Complete |
          \endif
    autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
    autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
    autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
    autocmd FileType ruby,eruby let g:rubycomplete_use_bundler = 1
    autocmd FileType ruby,eruby let ruby_fold = 1
    autocmd FileType ruby,eruby let ruby_spellcheck_strings = 1
    autocmd FileType ruby,eruby set keywordprg=ri " use ruby's ri instead of man for K command
    autocmd FileType ruby,eruby UltiSnipsAddFiletypes rails.ruby

    autocmd FileType ruby let &l:tags = pathogen#legacyjoin(pathogen#uniq(
          \ pathogen#split(&tags) +
          \ map(split($GEM_PATH,':'),'v:val."/gems/*/tags"')))
  augroup END
endif

if ! has('gui_running')
    set ttimeoutlen=10 lazyredraw
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType c set omnifunc=ccomplete#Complete


" For snippet_complete marker.
"if has('conceal')
"  set conceallevel=2 concealcursor=i
"endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""" RENAME CURRENT FILE
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

""""""""""""""""""""""""""""""""""""""""""""""" RemoveFancyCharacters COMMAND
function! RemoveFancyCharacters()
    let typo = {}
    let typo["“"] = '"'
    let typo["”"] = '"'
    let typo["‘"] = "'"
    let typo["’"] = "'"
    let typo["–"] = '--'
    let typo["—"] = '---'
    let typo["…"] = '...'
    :exe ":%s/".join(keys(typo), '\|').'/\=typo[submatch(0)]/ge'
endfunction
command! RemoveFancyCharacters :call RemoveFancyCharacters()

"--------------------------------------------------------- vim-easymotion ---
let g:EasyMotion_do_mapping = 0 " Disable default mappings

" Turn on case sensitive feature
let g:EasyMotion_smartcase = 1

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

"---------------------------------------------------------- NERDCommenter ---
let NERDSpaceDelims=1
if has("gui_macvim") && has("gui_running")
  map <D-/> <plug>NERDCommenterToggle<CR>
  imap <D-/> <Esc><plug>NERDCommenterToggle<CR>i
else
  map <leader>/ <plug>NERDCommenterToggle<CR>
endif


" Neomake
autocmd! BufWritePost * Neomake

" Deoplete
let g:deoplete#enable_at_startup = 1

"SUPERTAB
"let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabCrMapping = 0
let g:SuperTabClosePreviewOnPopupClose = 1
" let g:SuperTabLongestEnhanced = 1
" let g:SuperTabLongestHighlight = 1
let g:SuperTabDefaultCompletionType = 'context'
autocmd FileType *
      \ if &omnifunc != '' |
      \   call SuperTabChain(&omnifunc, "<c-p>") |
      \ endif

" ULTISNIPS
" make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-n>'

" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"


" EMMET
let g:user_emmet_expandabbr_key = '<Tab>'
let g:use_emmet_complete_tag = 1

" https://github.com/unblevable/quick-scope
let g:qs_enable = 0
let g:qs_enable_char_list = [ 'f', 'F', 't', 'T' ]

function! Quick_scope_selective(movement)
  let needs_disabling = 0
  if !g:qs_enable
    QuickScopeToggle
    redraw
    let needs_disabling = 1
  endif
  let letter = nr2char(getchar())
  if needs_disabling
    QuickScopeToggle
  endif
  return a:movement . letter
endfunction

" quick_scope maps, operator-pending mode included (can do 'df' with hint)
for i in g:qs_enable_char_list
  execute 'noremap <expr> <silent>' . i . " Quick_scope_selective('". i . "')"
endfor

"SYNTASTIC
let g:syntastic_enable_signs=1
let g:syntastic_check_on_open=1
let g:syntastic_check_on_wq=1
let g:syntastic_aggregate_errors=1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_enable_ballons=has('ballon_eval')
let g:syntastic_always_populate_loc_list=1
let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1
let g:syntastic_loc_list_height=3
let g:syntastic_ignore_files = ['^/usr/', '*node_modules*', '*vendor*', '*build*', '*LOCAL*', '*BASE', '*REMOTE*']
let g:syntastic_mode_map = { 'mode': 'active' }
let g:syntastic_javascript_checkers=['jshint', 'jscs']
let g:syntastic_json_checkers=['jsonlint', 'jsonval']
let g:syntastic_ruby_checkers=['rubocop','mri']
let g:syntastic_perl_checkers=['perl','perlcritic','podchecker']
let g:syntastic_python_checkers=['pylint','pep8','python']
let g:syntastic_cpp_checkers=['gcc','cppcheck','cpplint','ycm','clang_tidy','clang_check']
let g:syntastic_c_checkers=['gcc','make','cppcheck','clang_tidy','clang_check']
let g:syntastic_haml_checkers=['haml_lint', 'haml']
let g:syntastic_html_checkers=['jshint']
let g:syntastic_yaml_checkers=['jsyaml']
let g:syntastic_sh_checkers=['sh','shellcheck','checkbashisms']
let g:syntastic_vim_checkers=['vimlint']
let g:syntastic_enable_perl_checker=1
let g:syntastic_c_clang_tidy_sort=1
let g:syntastic_c_clang_check_sort=1
let g:syntastic_c_remove_include_errors=1
let g:syntastic_quiet_messages = { "level": "[]", "file": ['*_LOCAL_*', '*_BASE_*', '*_REMOTE_*']  }
let g:syntastic_stl_format = '[%E{E: %fe #%e}%B{, }%W{W: %fw #%w}]'
let g:syntastic_java_javac_options = "-g:none -source 8 -Xmaxerrs 5 -Xmaswarns 5"

if 0 " if 0 / endif HACK
i


.
endif

" AIRLINE
let g:airline#extensions#tabline#enabled = 0
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#buffer_idx_mode = 1
let g:airline#extensions#tmuxline#enabled = 1
let g:airline#extensions#tmuxline#snapshot_file = "~/.tmux-snapshot"
"let g:airline_theme = 'papercolor'


" UNITE
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
call unite#custom#profile('default', 'context', {'start_insert':1,'winheight':10,'direction':'dynamicbottom'})

let g:unite_data_directory="~/.vim/unite/cache" " s:get_cache_dir('unite')
let g:unite_source_history_yank_enable=1
let g:unite_source_rec_max_cache_files=5000

if executable('ag')
  " Use ag (the silver searcher)
  " https://github.com/ggreer/the_silver_searcher
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
  \ '-i --vimgrep --hidden --ignore ' .
  \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack')
  let g:unite_source_grep_command='ack'
  let g:unite_source_grep_default_opts='--no-heading --no-color -C4'
  let g:unite_source_grep_recursive_opt=''
endif

function! s:unite_settings()
  nmap <buffer> Q <plug>(unite_exit)
  nmap <buffer> <esc> <plug>(unite_exit)
  imap <buffer> <esc> <plug>(unite_exit)
endfunction
autocmd FileType unite call s:unite_settings()

"nmap <space> [unite]
"nnoremap [unite] <nop>

nnoremap <silent> <leader><space> :<C-u>Unite -toggle -auto-resize -buffer-name=mixed file_rec/async:! buffer file_mru bookmark<cr>
nnoremap <silent> <leader>t :<C-u>Unite -toggle -auto-resize -buffer-name=files file_rec/async:!<cr>
nnoremap <silent> <leader>e :<C-u>Unite -buffer-name=recent file_mru<cr>
" nnoremap <silent> <leader>y :<C-u>Unite -buffer-name=yanks history/yank<cr>
nnoremap <silent> <leader>l :<C-u>Unite -auto-resize -buffer-name=line line<cr>
nnoremap <silent> <leader>b :<C-u>Unite -auto-resize -buffer-name=buffers buffer file_mru<cr>
nnoremap <silent> <leader>f :<C-u>Unite -no-quit -buffer-name=search grep:.<cr>
nnoremap <silent> <leader>m :<C-u>Unite -auto-resize -buffer-name=mappings mapping<cr>
" nnoremap <silent> <leader>s :<C-u>Unite -quick-match buffer<cr>

" CMD-T - https://github.com/tsukkee/unite-tag
" noremap <M-D-T> :CtrlPTag<CR>
" inoremap <M-D-T> <ESC>:CtrlPTag<CR>

"}}}

